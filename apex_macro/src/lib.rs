#![allow(missing_docs)]
//! Apex macro crate providing the `#[component]` procedural macro for web component generation.

use proc_macro::TokenStream;
use syn::{DeriveInput, ItemFn, parse_macro_input};

use crate::{
    component::*,
    route::{generate_route, parse_route_args},
    tmpl::parse_tmpl,
};

mod component;
mod route;
pub(crate) mod tmpl;

/// Component macro that generates web component code from struct definitions
///
/// Usage:
/// ```rust
/// use apex_macro::component;
///
/// #[component]
/// pub struct MyComponent {
///     #[prop(default = 0)]
///     counter: i32,
///     name: String,
/// }
///
/// // Generated implementation includes:
/// // - new() constructor with default values
/// // - tag_name() returns the tag string
/// // - setter methods (set_counter, set_name)
/// // - Debug, Clone, Default, Display traits
/// ```
#[proc_macro_attribute]
pub fn component(args: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    // Parse the arguments to extract configuration
    let config = match parse_component_args(args) {
        Ok(config) => config,
        Err(err) => return err.to_compile_error().into(),
    };

    // Generate the component implementation
    match generate_component(&input, &config) {
        Ok(tokens) => tokens.into(),
        Err(err) => err.to_compile_error().into(),
    }
}

/// Route macro that generates route handler code from function definitions
///
/// Usage:
/// ```rust
/// use apex::{LoaderResult, HttpRequest, tmpl, Html};
/// use apex_macro::{route, component};
///
/// struct AppContext {
///     user_id: i32,
/// }
///
/// struct UserData {
///     name: String,
/// }
///
/// #[component]
/// pub struct UserProfile {
///     id: i32,
/// }
///
/// impl apex::View for UserProfile {
///     fn render(&self) -> Html {
///         tmpl! {
///             <div>
///                 <h1>Hello, World!</h1>
///             </div>
///         }
///     }
/// }
///
/// #[route(
///     path = "/users/:id",
///     component = UserProfile
/// )]
/// pub async fn user_profile(req: HttpRequest, context: &AppContext) -> LoaderResult<UserData> {
///     // This function signature will be generated by the macro
///     LoaderResult::ok(UserData { name: "John".to_string() })
/// }
/// ```
#[proc_macro_attribute]
pub fn route(args: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ItemFn);

    // Parse the arguments to extract route configuration
    let route_config = match parse_route_args(args) {
        Ok(config) => config,
        Err(err) => return err.to_compile_error().into(),
    };

    // Generate the route handler implementation
    match generate_route(&input, &route_config) {
        Ok(tokens) => tokens.into(),
        Err(err) => err.to_compile_error().into(),
    }
}

/// HTML macro that generates Html content from HTML-like syntax with component support
///
/// Usage:
/// ```rust,ignore
/// use apex::{tmpl, Html};
/// use apex::component;
///
/// #[component(tag = "my-counter")]
/// pub struct MyCounter {
///     name: String,
///     count: i32,
/// }
///
/// impl apex::View for MyCounter {
///     fn render(&self) -> Html {
///         tmpl! {
///             <div>
///                 <h1>Hello, {self.name}!</h1>
///                 <p>Count: {self.count}</p>
///             </div>
///         }
///     }
/// }
///
/// let name = "World";
/// let count = 42;
///
/// let html = tmpl! {
///     <div class="container">
///         <h1>Hello, {name}!</h1>
///         <p>Count: {count}</p>
///         <MyCounter name="Counter" count={count} />
///     </div>
/// };
/// ```
#[proc_macro]
pub fn tmpl(input: TokenStream) -> TokenStream {
    match parse_tmpl(input) {
        Ok(tokens) => tokens.into(),
        Err(err) => err.to_compile_error().into(),
    }
}
